#pragma config(Sensor, in1,    pot,            sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Motor,  port1,           leftDriveBack, tmotorVex393_HBridge, openLoop, driveLeft)
#pragma config(Motor,  port2,           rightInside,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port3,           rightOutside,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           rightDriveFront, tmotorVex393_MC29, openLoop, driveRight)
#pragma config(Motor,  port5,           clawRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           clawLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           leftDriveFront, tmotorVex393_MC29, openLoop, driveLeft)
#pragma config(Motor,  port8,           leftOutside,   tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           leftInside,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          rightDriveBack, tmotorVex393_HBridge, openLoop, driveRight)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

bool halfLift = false;
bool fullLift = false;
bool flatLift = false;

void drivePower(int power){
motor[leftDriveBack] = power;
motor[rightDriveBack] = power;
motor[leftDriveFront] = power;
motor[rightDriveFront] = power;
}

void liftPower(int power){
	motor[rightInside] = power;
	motor[rightOutside] = power;
	motor[leftInside] = power;
	motor[leftOutside] = power;
}

void clawPower(int power){
motor[clawLeft] = power;
motor[clawRight] = power;
}

int trueSpeed(int power) {
	int tsArray[128] =
	{
		25,  25,  25,  25,  25,  25,  25,  25,  25,  25,
	25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
	25, 25, 26, 26, 26, 27, 28, 28, 28, 29,
	29, 30, 30, 30, 30, 31, 31, 32, 32, 32,
	33, 33, 34, 34, 35, 35, 35, 36, 36, 37,
	37, 37, 37, 38, 38, 39, 39, 39, 40, 40,
	41, 41, 42, 42, 43, 44, 44, 45, 45, 46,
	46, 47, 47, 48, 48, 49, 50, 50, 51, 52,
	52, 53, 54, 55, 56, 57, 57, 58, 59, 60,
	61, 62, 63, 64, 65, 66, 67, 67, 68, 70,
	71, 72, 72, 73, 74, 76, 77, 78, 79, 79,
	80, 81, 83, 84, 84, 86, 86, 87, 87, 88,
	88, 89, 89, 90, 90, 127, 127, 127
	};
	return ((power>0)?1:-1)*tsArray[power*((power>0)?1:-1)];
}


task liftPID(){

int angle;

if(halfLift == true){
angle = 135;
}
if(fullLift == true){
angle  = 260;
}
if(flatLift == true){
angle = 0;
}

const float Kd = 2.0;
		const float Ki = 0.05;
		const float Kp = 0.3;

		int target = (angle/0.61) + 2247.5;
		int error;
		int integral = 0;
		int derivative;
		int lastError = 0;
		int dt = 5;


		while(error != 0){

		error = target - SensorValue[pot];
		integral = integral + error;
		derivative = error - lastError;
		lastError = error;

		liftPower((error*Kd)+(integral*Ki)+(derivative*Kp));

		wait1Msec(dt);
	}

}

void setHalfLift(int delay){
halfLift = true;
wait1Msec(delay);
halfLift = false;
}

void setFullLift(int delay){
fullLift = true;
wait1Msec(delay);
fullLift = false;
}

void setFlatLift(int delay){
flatLift = true;
wait1Msec(delay);
flatLift = false;
}

void leftDrive(int power){
motor[leftDriveBack] = power;
motor[leftDriveFront] = power;
}
void rightDrive(int power){
motor[rightDriveBack] = power;
motor[rightDriveFront] = power;
}

void pre_auton()
{
  bStopTasksBetweenModes = true;
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task autonomous()
{
startTask(liftPID);

setFlatLift(400);

}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*
int rightDrive = motor[rightDrive]; You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/

task usercontrol()
{



  while (true)
  {
  	startTask(liftPID);

  if(vexRT[Btn6U] == 1){
flatLift = true;
}else{
flatLift = false;
}
if(vexRT[Btn6D] == 1){
	halfLift = true;
}else{
flatLift = false;
}
if(vexRT[Btn5U] == 1){
fullLift = true;
}else{
fullLift = false;
}

  leftDrive(trueSpeed(vexRT[Ch3]));
  rightDrive(trueSpeed(vexRT[Ch2]));

  }
}
